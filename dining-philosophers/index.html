<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="ru">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">





  <meta name="keywords" content="programming, concurrency, dotnet,">




  


  <link rel="alternate" href="/atom.xml" title="Артём Карпов" type="application/atom+xml">






<meta name="description" content="Давайте посмотрим как устроено конкурентное и параллельное программирование в .Net, на примере проблемы обедающих философов. План такой, от синхронизации потоков/процессов, до модели акторов (в следу">
<meta name="keywords" content="programming, concurrency, dotnet">
<meta property="og:type" content="article">
<meta property="og:title" content="Сытые философы или конкурентное программирование на .NET">
<meta property="og:url" content="http://www.artkpv.net/dining-philosophers/index.html">
<meta property="og:site_name" content="Артём Карпов">
<meta property="og:description" content="Давайте посмотрим как устроено конкурентное и параллельное программирование в .Net, на примере проблемы обедающих философов. План такой, от синхронизации потоков/процессов, до модели акторов (в следу">
<meta property="og:locale" content="ru">
<meta property="og:image" content="http://www.artkpv.net/dining-philosophers/dotnet_logo.png">
<meta property="og:image" content="http://www.artkpv.net/dining-philosophers/livelock.png">
<meta property="og:image" content="http://www.artkpv.net/dining-philosophers/starvation.png">
<meta property="og:image" content="http://www.artkpv.net/dining-philosophers/spinlock.png">
<meta property="og:updated_time" content="2020-03-05T12:51:06.921Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Сытые философы или конкурентное программирование на .NET">
<meta name="twitter:description" content="Давайте посмотрим как устроено конкурентное и параллельное программирование в .Net, на примере проблемы обедающих философов. План такой, от синхронизации потоков/процессов, до модели акторов (в следу">
<meta name="twitter:image" content="http://www.artkpv.net/dining-philosophers/dotnet_logo.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.artkpv.net/dining-philosophers/">





  <title>Сытые философы или конкурентное программирование на .NET | Артём Карпов</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="ru">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Артём Карпов</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Главная</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>О сайте | About</a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.artkpv.net/dining-philosophers/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Артём Карпов">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Артём Карпов">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Сытые философы или конкурентное программирование на .NET</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Размещено</span>
              
              <time title="Дата создания записи" itemprop="dateCreated datePublished" datetime="2019-05-22T00:00:00+03:00">2019-05-22</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/dining-philosophers/dotnet_logo.png">
<p>Давайте посмотрим как устроено конкурентное и параллельное программирование в .Net, на примере проблемы обедающих философов. План такой, от синхронизации потоков/процессов, до модели акторов (в следующих частях). Статья может быть полезна для первого знакомства или для того, чтобы освежить свои знания.</p>
<p>Зачем вообще уметь это? Транзисторы достигают своего минимального размера, закон Мура упирается в ограничение скорости света и поэтому рост наблюдается в количестве, транзисторов можно делать больше. При этом количество данных растет, а пользователи ожидают немедленной реакции систем. В такой ситуации “обычное” программирование, когда у нас один выполняющий поток, уже не эффективно. Нужно как-то решать проблему одновременного или конкурентного выполнения. Причем, проблема эта существует на разных уровнях: на уровне потоков, на уровне процессов, на уровне машин в сети (распределенные системы). В .NET есть качественные, проверенные временем, технологии для быстрого и эффективного решения таких задач.</p>
<a id="more"></a>
<h2 id="Задача"><a href="#Задача" class="headerlink" title="Задача"></a>Задача</h2><p>Эдсгер Дейкстра задавал эту проблему своим ученикам еще в 1965. Устоявшаяся формулировка такая. Есть некоторое (обычно пять) количество философов и столько же вилок. Они сидят за круглым столом, вилки между ними. Философы могут есть из своих тарелок с бесконечной пищей, думать или ждать. Чтобы поесть философу, нужно взять две вилки (последний делит вилку с первым). Взять и положить вилку - два раздельных действия. Все философы безмолвные. Задача найти такой алгоритм, чтобы все они думали и были сыты спустя даже 54 года.</p>
<p>Сначала попробуем решить эту задачу через использование разделяемого места. Вилки лежат на общем столе и философы просто их берут, когда они есть, и кладут обратно. Здесь появляются проблемы с синхронизацией, когда именно брать вилки? что делать если вилки нет? и др. Но сначала давайте запустим философов.</p>
<p>Для запуска потоков используем пул потоков через <code>Task.Run</code> метод:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> cancelTokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">Action&lt;<span class="keyword">int</span>&gt; create = (i) =&gt; RunPhilosopher(i, cancelTokenSource.Token);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; philosophersAmount; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> icopy = i;</span><br><span class="line">    <span class="comment">// Поместить задачу в очередь пула потоков. Метод RunDeadlock не запускаеться </span></span><br><span class="line">    <span class="comment">// сразу, а ждет своего потока. Асинхронный запуск.</span></span><br><span class="line">    philosophers[i] = Task.Run(() =&gt; create(icopy), cancelTokenSource.Token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Пул потоков создан для оптимизации создания и удаления потоков. У этого пула есть очередь с задачами и CLR создает или удаляет потоки в зависимости от количества этих задач. Один пул на все AppDomain’ы. Этот пул стоит использовать почти всегда, т.к. не нужно заморачиваться с созданием, удалением потоков, их очередями и пр. Можно и без пула, но тогда придется напрямую использовать <code>Thread</code>, это целесообразно для случаев, когда нужно поменять приоритет потоку, когда у нас долгая операция, для Foreground потока и др. </p>
<p>А <code>System.Threading.Tasks.Task</code> класс, как раз позволяет легко работать с этим пулом потоков (или вообще обходиться без него). Он представляет собой асинхронную операцию. Грубо говоря, это тот же <code>Thread</code>, но со всякими удобствами: возможность запускать таск после блока других тасков, возвращать их из функций, удобно их прерывать и мн. др. Они нужны для поддержки async/await конструкций (Task-based Asynchronous Pattern, синтаксический сахар для ожидания IO операции). Об этом еще поговорим.</p>
<p><code>CancelationTokenSource</code> здесь нужен, чтобы поток мог сам завершится по сигналу вызывающего потока.</p>
<h2 id="Проблемы-с-синхронизацией"><a href="#Проблемы-с-синхронизацией" class="headerlink" title="Проблемы с синхронизацией"></a>Проблемы с синхронизацией</h2><h3 id="Блокированные-философы"><a href="#Блокированные-философы" class="headerlink" title="Блокированные философы"></a>Блокированные философы</h3><p>Хорошо, мы умеем создавать потоки, давайте попробуем пообедать:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Кто какие вилки взял. К примеру: 1 1 3 3 - 1й и 3й взяли первые две пары.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] forks = Enumerable.Repeat(<span class="number">0</span>, philosophersAmount).ToArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// То же, что RunPhilosopher()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RunDeadlock</span>(<span class="params"><span class="keyword">int</span> i, CancellationToken token</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Ждать вилку, взять её. Эквивалентно: </span></span><br><span class="line">    <span class="comment">// while(true) </span></span><br><span class="line">    <span class="comment">//     if forks[fork] == 0 </span></span><br><span class="line">    <span class="comment">//          forks[fork] = i+1</span></span><br><span class="line">    <span class="comment">//          break</span></span><br><span class="line">    <span class="comment">//     Thread.Sleep() или Yield() или SpinWait()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TakeFork</span>(<span class="params"><span class="keyword">int</span> fork</span>) </span>=&gt;</span><br><span class="line">        SpinWait.SpinUntil(() =&gt; </span><br><span class="line">            Interlocked.CompareExchange(<span class="keyword">ref</span> forks[fork], i+<span class="number">1</span>, <span class="number">0</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Для простоты, но можно с Interlocked.Exchange:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PutFork</span>(<span class="params"><span class="keyword">int</span> fork</span>) </span>=&gt; forks[fork] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TakeFork(Left(i));</span><br><span class="line">        TakeFork(Right(i));</span><br><span class="line">        eatenFood[i] = (eatenFood[i] + <span class="number">1</span>) % (<span class="keyword">int</span>.MaxValue - <span class="number">1</span>);</span><br><span class="line">        PutFork(Left(i));</span><br><span class="line">        PutFork(Right(i));</span><br><span class="line">        Think(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Завершить работу по-хорошему.</span></span><br><span class="line">        token.ThrowIfCancellationRequested();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Здесь мы сначала пробуем взять левую, а потом правую вилки и если получилось, то едим и кладем их обратно. Взятие одной вилки атомарно, т.е. два потока не могут взять одну одновременно (неверно: первый читает, что вилка свободна, второй – тоже, первый берет, второй берет). Для этого <code>Interlocked.CompareExchange</code>, который должен быть реализован с помощью инструкции процессора (<code>TSL</code>, <code>XCHG</code>), которая блокирует участок памяти для атомарного последовательного чтения и записи. А SpinWait эквивалентно конструкции <code>while(true)</code> только с небольшой “магией” – поток занимает процессор (<code>Thread.SpinWait</code>), но иногда передает управление другому потоку (<code>Thread.Yeild</code>) или засыпает (<code>Thread.Sleep</code>).</p>
<p>Но это решение не работает, т.к. потоки скоро (у меня в течении секунды) блокируются: все философы берут свою левую вилку, а правой нет. Массив forks тогда имеет значения: 1 2 3 4 5. </p>
<img src="/dining-philosophers/livelock.png">
<p>На рисунке, блокирование потоков (deadlock). Зеленым цветом – выполнение, красным – синхронизация, серым – поток спит. Ромбиками обозначено время запуска Task’ов.</p>
<h3 id="Голод-философов"><a href="#Голод-философов" class="headerlink" title="Голод философов"></a>Голод философов</h3><p>Хотя чтобы мыслить особенно много еды не нужно, но голод кого угодно заставить бросить философию. Попробуем смоделировать ситуацию голодания потоков в нашей задаче. Голодание – это когда поток работает, но без существенной работы, другими словами это тот же дедлок, только теперь поток не спит, а активно ищет как бы поесть, но еды нет. Для того, чтобы избежать частую блокировку будем класть вилку назад, если не смогли взять другую.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// То же что и в RunDeadlock, но теперь кладем вилку назад и добавляем плохих философов.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RunStarvation</span>(<span class="params"><span class="keyword">int</span> i, CancellationToken token</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> hasTwoForks = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">var</span> waitTime = TimeSpan.FromMilliseconds(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">// Плохой философов может уже иметь вилку:</span></span><br><span class="line">        <span class="keyword">bool</span> hasLeft = forks[Left(i)] == i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasLeft || TakeFork(Left(i), i + <span class="number">1</span>, waitTime))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (TakeFork(Right(i), i + <span class="number">1</span>, TimeSpan.Zero))</span><br><span class="line">                hasTwoForks = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                PutFork(Left(i)); <span class="comment">// Иногда плохой философ отдает вилку назад.</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (!hasTwoForks)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.IsCancellationRequested) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        eatenFood[i] = (eatenFood[i] + <span class="number">1</span>) % (<span class="keyword">int</span>.MaxValue - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> goodPhilosopher = i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// А плохой философ забывает положить свою вилку обратно:</span></span><br><span class="line">        <span class="keyword">if</span> (goodPhilosopher)</span><br><span class="line">            PutFork(Left(i));</span><br><span class="line">        <span class="comment">// А если и правую не положит, то хорошие будут вообще без еды.</span></span><br><span class="line">        PutFork(Right(i));</span><br><span class="line"></span><br><span class="line">        Think(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Теперь можно ждать определенное время.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TakeFork</span>(<span class="params"><span class="keyword">int</span> fork, <span class="keyword">int</span> philosopher, TimeSpan? waitTime = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SpinWait.SpinUntil(</span><br><span class="line">        () =&gt; Interlocked.CompareExchange(<span class="keyword">ref</span> forks[fork], philosopher, <span class="number">0</span>) == <span class="number">0</span>,</span><br><span class="line">              waitTime ?? TimeSpan.FromMilliseconds(<span class="number">-1</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>В этом коде важно то, что два из четырех философа забывают положить свою левую вилку. И получается, что они едят больше еды, а другие начинают голодать, хотя у потоков одинаковый приоритет. Здесь они не совсем голодают, т.к. плохие философы кладут свои вилки иногда назад. У меня получается, что хорошие едят где-то в 5 раз меньше, чем плохие. Так небольшая ошибка в коде приводит к тому, что падает производительность. Здесь еще стоит заметить, что возможна редкая ситуация, когда все философы берут левую вилку, правой нет, они кладут левую, ждут, опять берут левую и т.д. Эта ситуация тоже голодание, больше похожая на взаимную блокировку. Повторить ее у меня не получилось. Ниже картинка для ситуации, когда два плохих философа забрали обе вилки, а два хороших голодают.</p>
<img src="/dining-philosophers/starvation.png">
<p>Здесь видно, что потоки просыпаются иногда и пробуют получить ресурс. Два ядра из четырех ничего не делают (зеленый график вверху). </p>
<h3 id="Смерть-философа"><a href="#Смерть-философа" class="headerlink" title="Смерть философа"></a>Смерть философа</h3><p>Ну и еще одна проблема, которая может прервать славный обед философов – это если один из них внезапно умрёт с вилками в руках (и его так и похоронят). Тогда соседи останутся без обеда. Пример кода для этого случая вы можете придумать и сами, например выбрасывается <code>NullReferenceException</code> после того, как философ берет вилки. И, между прочим, исключение будет не обработанным и вызывающий код его просто так не поймает (для этого <code>AppDomain.CurrentDomain.UnhandledException</code> и др.). Поэтому обработчики ошибок необходимы в самих потоках и с корректным завершением.</p>
<h2 id="Официант"><a href="#Официант" class="headerlink" title="Официант"></a>Официант</h2><p>Хорошо, как нам решить эту проблему с взаимными блокировками, голоданием и смертями? Будем допускать только одного философа до вилок, добавим взаимное исключение (mutual exclusion) потоков для этого места. Как это сделать? Предположим, что рядом с философами стоит официант, который дает разрешение какому-нибудь одному философу взять вилки. Как нам сделать этого официанта и как философы будут просить его, вопросы интересные. </p>
<p>Простейший способ – это когда философы будут просто постоянно просить официанта дать доступ к вилкам. Т.е. теперь философы будут не ждать вилку рядом, а ждать или просить официанта. Сначала используем для этого только User Space, в нем мы не используем прерывания для вызова каких-нибудь процедур из ядра (о них ниже).</p>
<h3 id="Решения-в-пространстве-пользователя"><a href="#Решения-в-пространстве-пользователя" class="headerlink" title="Решения в пространстве пользователя"></a>Решения в пространстве пользователя</h3><p>Здесь будем делать тоже, что раньше делали с одной вилкой и двумя философами, будем крутиться в цикле и ждать. Но теперь это будут все философы и как бы только одна вилка, т.е. можно сказать будет есть только тот философ, который взял эту “золотую вилку” у официанта. Для этого используем SpinLock.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SpinLock spinLock = <span class="keyword">new</span> SpinLock();  <span class="comment">// Наш "официант"</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RunSpinLock</span>(<span class="params"><span class="keyword">int</span> i, CancellationToken token</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Взаимная блокировка через busy waiting. Вызываем до try, чтобы</span></span><br><span class="line">        <span class="comment">// выбрасить исключение в случае ошибки в самом SpinLock.</span></span><br><span class="line">        <span class="keyword">bool</span> hasLock = <span class="literal">false</span>;</span><br><span class="line">        spinLock.Enter(<span class="keyword">ref</span> hasLock);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Здесь может быть только один поток (mutual exclusion).</span></span><br><span class="line">            forks[Left(i)] = i + <span class="number">1</span>;  <span class="comment">// Берем вилку сразу, без ожидания.</span></span><br><span class="line">            forks[Right(i)] = i + <span class="number">1</span>;</span><br><span class="line">            eatenFood[i] = (eatenFood[i] + <span class="number">1</span>) % (<span class="keyword">int</span>.MaxValue - <span class="number">1</span>);</span><br><span class="line">            forks[Left(i)] = <span class="number">0</span>;</span><br><span class="line">            forks[Right(i)] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasLock) spinLock.Exit();  <span class="comment">// Избегаем проблемы со смертью философа.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Think(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SpinLock</code> это блокировщик, с, грубо говоря, тем же <code>while(true) { if (!lock) break; }</code>, но с еще большей “магией”, чем в <code>SpinWait</code> (который там используется). Теперь он умеет считать ожидающих, немного усыплять их и мн. др. В общем, делает всё возможное для оптимизации. Но надо помнить, что это всё тот же активный цикл, который ест ресурсы процессора и держит поток, который может привести к голоданию, если один из философов становится приоритетнее других, но не имеет золотой вилки (Priority Inversion problem). Поэтому используем его только для очень очень коротких изменений в общей памяти, без всяких сторонних вызовов, вложенных блокировок и пр. сюрпризов.</p>
<img src="/dining-philosophers/spinlock.png">
<p>Рисунок для <code>SpinLock</code>. Потоки постоянно “воюют” за золотую вилку. Случаются провалы – на рисунке выделенная область. Ядра используются не полностью: только около 2/3 этими четырьмя потоками.</p>
<p>Другое решение здесь было бы использовать только <code>Interlocked.CompareExchange</code> с тем же активным ожиданием, как показано в коде выше (в голодающих философах), но это, как было уже сказано, теоретически может привести к блокировке. </p>
<p>Про <code>Interlocked</code> стоит сказать, что там не только <code>CompareExchange</code>, но и другие методы для атомарного чтения И записи. А через повтор изменения в случае, если другой поток успевает внести свои изменения (чтение 1, чтение 2, запись 2, запись 1 плохая), он может использоваться для сложных изменений одного значения (Interlocked Anything паттерн).</p>
<h3 id="Решения-в-режиме-ядра"><a href="#Решения-в-режиме-ядра" class="headerlink" title="Решения в режиме ядра"></a>Решения в режиме ядра</h3><p>Чтобы избежать потери ресурсов в цикле, посмотрим как можно блокировать поток. Другими словами, продолжая наш пример, посмотрим, как официант усыпит философа и разбудит его только тогда, когда надо. Сначала рассмотрим, как это сделать через режим ядра операционной системы. Все структуры там часто оказываются медленнее, чем те, что в пространстве пользователя. Медленнее в несколько раз, например <code>AutoResetEvent</code> может быть в 53 раза медленнее <code>SpinLock</code> [Рихтер]. Но с их помощью можно синхронизировать процессы по всей системе, управляемые или нет.</p>
<p>Основная конструкция здесь это семафор, предложенный Дейкстрой более полувека назад. Семафор это, упрощенно говоря, положительное целое число, управляемое системой, и две операции на нем, – увеличить и уменьшить. Если уменьшить не получается, ноль, то вызывающий поток блокируется. Когда число увеличивается каким-нибудь другим активным потоком/процессом, тогда потоки пропускаются, а семафор опять уменьшается на число прошедших. Можно представить поезда в узком месте с семафором. .NET предлагает несколько конструкций с подобными функциями: <code>AutoResetEvent</code>, <code>ManualResetEvent</code>, <code>Mutex</code> и сам <code>Semaphore</code>. Мы будем использовать <code>AutoResetEvent</code>, это самая простая из этих конструкций: только два значения 0 и 1 (false, true). Ее метод <code>WaitOne()</code> блокирует вызывающий поток, если значение было 0, а если 1, то понижает до 0 и пропускает его. А метод <code>Set()</code> повышает до 1 и пропускает одного ожидающего, который опять понижает до 0. Действует, как турникет в метро.</p>
<p>Усложним решение и будем использовать блокировку для каждого философа, а не для всех сразу. Т.е. теперь есть могут сразу несколько философов, а не один. Но мы опять блокируем доступ к столу, для того чтобы корректно, избегая гонок (race conditions), взять вилки. </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Для блокирования отдельного философа.</span></span><br><span class="line"><span class="comment">// Инициализируется: new AutoResetEvent(true) для каждого.</span></span><br><span class="line"><span class="keyword">private</span> AutoResetEvent[] philosopherEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Для доступа к вилкам / доступ к столу.</span></span><br><span class="line"><span class="keyword">private</span> AutoResetEvent tableEvent = <span class="keyword">new</span> AutoResetEvent(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Рождение философа.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">int</span> i, CancellationToken token</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TakeForks(i); <span class="comment">// Ждет вилки.</span></span><br><span class="line">        <span class="comment">// Обед. Может быть и дольше.</span></span><br><span class="line">        eatenFood[i] = (eatenFood[i] + <span class="number">1</span>) % (<span class="keyword">int</span>.MaxValue - <span class="number">1</span>);</span><br><span class="line">        PutForks(i); <span class="comment">// Отдать вилки и разблокировать соседей.</span></span><br><span class="line">        Think(i);</span><br><span class="line">        <span class="keyword">if</span> (token.IsCancellationRequested) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ожидать вилки в блокировке.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TakeForks</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasForks = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!hasForks) <span class="comment">// Попробовать еще раз (блокировка не здесь).</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Исключающий доступ к столу, без гонок за вилками.</span></span><br><span class="line">        tableEvent.WaitOne();</span><br><span class="line">        <span class="keyword">if</span> (forks[Left(i)] == <span class="number">0</span> &amp;&amp; forks[Right(i)] == <span class="number">0</span>)</span><br><span class="line">            forks[Left(i)] = forks[Right(i)] = i + <span class="number">1</span>;</span><br><span class="line">        hasForks = forks[Left(i)] == i + <span class="number">1</span> &amp;&amp; forks[Right(i)] == i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasForks)</span><br><span class="line">            <span class="comment">// Теперь философ поест, выйдет из цикла. Если Set </span></span><br><span class="line">            <span class="comment">// вызван дважды, то значение true.</span></span><br><span class="line">            philosopherEvents[i].Set();</span><br><span class="line">        <span class="comment">// Разблокировать одного ожидающего. После него значение tableEvent в false.</span></span><br><span class="line">        tableEvent.Set(); </span><br><span class="line">        <span class="comment">// Если имеет true, не блокируется, а если false, то будет ждать Set от соседа.</span></span><br><span class="line">        philosopherEvents[i].WaitOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Отдать вилки и разблокировать соседей.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutForks</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tableEvent.WaitOne(); <span class="comment">// Без гонок за вилками.</span></span><br><span class="line">    forks[Left(i)] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Пробудить левого, а потом и правого соседа, либо AutoResetEvent в true.</span></span><br><span class="line">    philosopherEvents[LeftPhilosopher(i)].Set();</span><br><span class="line">    forks[Right(i)] = <span class="number">0</span>;</span><br><span class="line">    philosopherEvents[RightPhilosopher(i)].Set();</span><br><span class="line">    tableEvent.Set();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Чтобы понять, что тут происходит, рассмотрим случай, когда философу не удалось взять вилки, тогда его действия будут такими. Он ждет доступа к столу. Получив его он пробует взять вилки. Не получилось. Он отдает доступ к столу (взаимное исключение). И проходит свой “турникет” (<code>AutoResetEvent</code>) (вначале они открыты). Попадает опять в цикл, т.к. у него нет вилок. Пробует взять их и останавливается у своего “турникета”. Какой-нибудь более удачливый сосед справа или слева, закончив есть, разблокирует нашего философа, “открывая его турникет”. Наш философ проходит его (и он закрывается за ним) во второй раз. Пробует в третий раз взять вилки. Удачно. И проходит свой турникет, чтобы отобедать.</p>
<p>Когда в таком коде будут случайные ошибки (они всегда есть), например будет неверно указан сосед или создан один и тот же объект <code>AutoResetEvent</code> для всех (<code>Enumerable.Repeat</code>), тогда философы будут ждать уже разработчиков, т.к. поиск ошибок в таком коде довольно сложное занятие. Ещё одна проблема с этим решением в том, что оно не гарантирует, что какой-нибудь философ не начнет голодать.</p>
<h3 id="Гибридные-решения"><a href="#Гибридные-решения" class="headerlink" title="Гибридные решения"></a>Гибридные решения</h3><p>Мы рассмотрели два подхода к синхронизации, когда мы остаемся в режиме пользователя и крутимся в цикле и, когда мы блокируем поток через ядро. Первый метод хорош для кратких блокировок, второй для длительных. Часто требуется сначала кратко ожидать изменения переменной в цикле, а потом заблокировать поток, когда ожидание долгое. Этот подход реализован в т.н. гибридных конструкциях. Здесь есть те же конструкции, что были для режима ядра, но теперь с циклом в режиме пользователя: <code>SemaphorSlim</code>, <code>ManualResetEventSlim</code> и др. Самая популярная конструкция здесь это <code>Monitor</code>, т.к. в C# есть известный всем <code>lock</code> синтаксис. <code>Monitor</code> это тот же семафор с максимальным значением 1 (мютекс), но с поддержкой ожидания в цикле, рекурсии, Condition Variable паттерна (о нем ниже) и др. Посмотрим на решение с ним.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Спрячем объект для Монитора от всех, чтобы без дедлоков.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _lock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"><span class="comment">// Время ожидания потока.</span></span><br><span class="line"><span class="keyword">private</span> DateTime?[] _waitTimes = <span class="keyword">new</span> DateTime?[philosophersAmount];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"><span class="keyword">int</span> i, CancellationToken token</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TakeForks(i);</span><br><span class="line">        eatenFood[i] = (eatenFood[i] + <span class="number">1</span>) % (<span class="keyword">int</span>.MaxValue - <span class="number">1</span>);</span><br><span class="line">        PutForks(i);</span><br><span class="line">        Think(i);</span><br><span class="line">        <span class="keyword">if</span> (token.IsCancellationRequested) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Наше сложное условие для Condition Variable паттерна.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CanIEat</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Если есть вилки:</span></span><br><span class="line">    <span class="keyword">if</span> (forks[Left(i)] != <span class="number">0</span> &amp;&amp; forks[Right(i)] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> now = DateTime.Now;</span><br><span class="line">    <span class="comment">// Может, если соседи не более голодные, чем текущий.</span></span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> p <span class="keyword">in</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;LeftPhilosopher(i), RightPhilosopher(i)&#125;)</span><br><span class="line">        <span class="keyword">if</span> (_waitTimes[p] != <span class="literal">null</span> &amp;&amp; now - _waitTimes[p] &gt; now - _waitTimes[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TakeForks</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Зайти в Монитор. То же самое: lock(_lock) &#123;..&#125;.</span></span><br><span class="line">    <span class="comment">// Вызываем вне try, чтобы возможное исключение выбрасывалось выше.</span></span><br><span class="line">    <span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    Monitor.Enter(_lock, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        _waitTimes[i] = DateTime.Now;</span><br><span class="line">        <span class="comment">// Condition Variable паттерн. Освобождаем лок, если не выполненно </span></span><br><span class="line">        <span class="comment">// сложное условие. И ждем пока кто-нибудь сделает Pulse / PulseAll.</span></span><br><span class="line">        <span class="keyword">while</span> (!CanIEat(i))</span><br><span class="line">            Monitor.Wait(_lock); </span><br><span class="line">        forks[Left(i)] = i + <span class="number">1</span>;</span><br><span class="line">        forks[Right(i)] = i + <span class="number">1</span>;</span><br><span class="line">        _waitTimes[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken) Monitor.Exit(_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutForks</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// То же самое: lock (_lock) &#123;..&#125;.</span></span><br><span class="line">    <span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line">    Monitor.Enter(_lock, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        forks[Left(i)] = <span class="number">0</span>;</span><br><span class="line">        forks[Right(i)] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Освободить все потоки в очереди ПОСЛЕ вызова Monitor.Exit.</span></span><br><span class="line">        Monitor.PulseAll(_lock); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lockTaken) Monitor.Exit(_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Здесь мы опять блокируем весь стол для доступа к вилкам, но теперь мы разблокируем все сразу потоки, а не соседей, когда кто-нибудь заканчивает есть. Т.е. сначала, кто-нибудь ест и блокирует соседей, а когда этот кто-нибудь заканчивает, но хочет сразу опять есть, он уходит в блокировку и будит своих соседей, т.к. его время ожидания меньше. </span><br><span class="line"></span><br><span class="line">Так мы избегаем дедлоков и голодания какого-нибудь философа. Используем цикл для краткого ожидания и блокируем поток для долгого. Разблокировка сразу всех работает медленнее, чем если бы была разблокировка только соседа, как в решении с `AutoResetEvent`, но разница не должна быть большой, т.к. потоки должны остаться в режиме пользователя сначала. </span><br><span class="line"></span><br><span class="line">У `<span class="keyword">lock</span>` синтаксиса есть неприятные сюрпризы. Рекомендуют использовать `Monitor` напрямую [Рихтер] [Эрик Липперт]. Один из них в том, что `<span class="keyword">lock</span>` всегда выходит из `Monitor`, даже если было исключение, и тогда другой поток может изменить состояние общей памяти. В таких случаях чаще лучше уходить в дедлок или как-то безопасно завершать программу. Другой сюрприз в том, что Monitor использует блоки синхронизации (`SyncBlock`), которые есть во всех объектах. Поэтому, если выбран неподходящий объект, можно легко получить дедлок (например, если сделать лок на интернированную строку). Используем всегда скрытый объект для этого.</span><br><span class="line"></span><br><span class="line">Condition Variable паттерн позволяет более кратко реализовать ожидание какого-нибудь сложного условия. В .NET он неполный, на мой взгляд, т.к. по идее там должны быть несколько очередей на нескольких переменных (как в Posix Threads), а не на одном локе. Тогда можно было бы сделать их для всех философов. Но и в таком виде он позволяет сократить код.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">### Много философов или `async` / `await`</span></span><br><span class="line"></span><br><span class="line">Хорошо, теперь мы умеем эффективно блокировать потоки. Но, а если у нас становится много философов? <span class="number">100</span>? <span class="number">10000</span>? Например, нам пришло <span class="number">100000</span> запросов на веб-сервер. Создавать для каждого запроса поток будет накладным, т.к. столько потоков параллельно не будут выполняться. Будут выполняться только столько, сколько логических ядер (у меня <span class="number">4</span>). А все остальные будут просто отнимать ресурсы. Одно из решений этой проблемы <span class="keyword">async</span> / <span class="keyword">await</span> паттерн. Идея его в том, что функция не держит поток, если для её продолжения нужно что-то подождать. А когда, она это что-то происходит, она возобновляет свое выполнение (но не обязательно в том же потоке!). В нашем случае, мы будем ждать вилки. </span><br><span class="line"></span><br><span class="line">`SemaphoreSlim` имеет для этого `WaitAsync()` метод. Вот реализация с использованием этого паттерна. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` csharp</span><br><span class="line"></span><br><span class="line"><span class="comment">// Запуск такой же, как раньше. Где-нибудь в программе:</span></span><br><span class="line">Task.Run(() =&gt; Run(i, cancelTokenSource.Token));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Запуск философа.</span></span><br><span class="line"><span class="comment">// Ключевое слово async -- компилятор транслирует этот метот в асинхронный.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Run</span>(<span class="params"><span class="keyword">int</span> i, CancellationToken token</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// await -- будем ожидать какого-то события.</span></span><br><span class="line">        <span class="keyword">await</span> TakeForks(i);</span><br><span class="line">        <span class="comment">// После await, продолжение возможно в другом потоке.</span></span><br><span class="line">        eatenFood[i] = (eatenFood[i] + <span class="number">1</span>) % (<span class="keyword">int</span>.MaxValue - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Может быть несколько событий для ожидания.</span></span><br><span class="line">        <span class="keyword">await</span> PutForks(i);</span><br><span class="line"></span><br><span class="line">        Think(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token.IsCancellationRequested) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">TakeForks</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasForks = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!hasForks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Взаимоисключающий доступ к столу:</span></span><br><span class="line">        <span class="keyword">await</span> _tableSemaphore.WaitAsync();</span><br><span class="line">        <span class="keyword">if</span> (forks[Left(i)] == <span class="number">0</span> &amp;&amp; forks[Right(i)] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            forks[Left(i)] = i+<span class="number">1</span>;</span><br><span class="line">            forks[Right(i)] = i+<span class="number">1</span>;</span><br><span class="line">            hasForks = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _tableSemaphore.Release();</span><br><span class="line">        <span class="comment">// Будем ожидать, чтобы сосед положил вилки:</span></span><br><span class="line">        <span class="keyword">if</span> (!hasForks)</span><br><span class="line">            <span class="keyword">await</span> _philosopherSemaphores[i].WaitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ждем доступа к столу и кладем вилки.</span></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">PutForks</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> _tableSemaphore.WaitAsync();</span><br><span class="line">    forks[Left(i)] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// "Пробудить" соседей, если они "спали".</span></span><br><span class="line">    _philosopherSemaphores[LeftPhilosopher(i)].Release();</span><br><span class="line">    forks[Right(i)] = <span class="number">0</span>;</span><br><span class="line">    _philosopherSemaphores[RightPhilosopher(i)].Release();</span><br><span class="line">    _tableSemaphore.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Метод с <code>async</code> / <code>await</code> транслируется в хитрый конечный автомат, который сразу возвращает свой внутренний <code>Task</code>. Через него можно ждать завершения метода, отменять его и всё прочее, что можно делать с Task. Внутри метода, конечный автомат, контролирует выполнение. Суть в том, что если нет задержки, то выполнение синхронное, а если есть, то поток освобождается. Для лучшего понимания этого лучше посмотреть этот конечный автомат. Можно создавать цепочки из этих <code>async</code> / <code>await</code> методов. </p>
<p>Потестируем. Работа 100 философов на машине с 4 логическими ядрами, 8 секунд. Предыдущее решение с Monitor выполняло только 4 первых потока, а остальные вообще не выполнялись. Каждый из этих 4 потоков простаивал около 2мс. А решение с async / await выполняло все 100, при этом в среднем каждый ждал 6.8 секунд. Конечно, в реальных системах простаивание по 6 секунд неприемлемо и лучше не обрабатывать столько запросов так. Решение же с Monitor оказалось не масштабируемым вообще.</p>
<h2 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h2><p>Как видно из этих небольших примеров, .NET поддерживает много конструкций синхронизации. Не всегда, впрочем, очевидно, как их использовать. Надеюсь эта статья оказалась полезной. Пока на этом завершаем, но осталось еще много интересного, например потокобезопасные коллекции, TPL Dataflow, Reactive программирование, Software Transaction модель и др. </p>
<h2 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h2><ul>
<li>Визуализация потоков: <a href="https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer" target="_blank" rel="noopener">Concurrency Visualizer</a></li>
<li>MSDN: <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/" target="_blank" rel="noopener">Threading</a>, <a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/" target="_blank" rel="noopener">Asynchronous programming patterns</a> и мн. др.</li>
<li>[Рихтер] - CLR via C#, Jeffrey Richter</li>
<li>[Эрик Липперт] - <a href="https://blogs.msdn.microsoft.com/ericlippert/2009/03/06/locks-and-exceptions-do-not-mix/" target="_blank" rel="noopener">О lock</a></li>
<li><a href="https://github.com/artkpv/dotnetconcurrency" target="_blank" rel="noopener">Исходный код</a></li>
<li>Картинка - “Танец среди мечей”, Г. Семирадский</li>
</ul>
<p>Публикация на Хабре: <a href="https://habr.com/ru/post/447898/" target="_blank" rel="noopener">https://habr.com/ru/post/447898/</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tag/programming-concurrency-dotnet/" rel="tag"># programming, concurrency, dotnet</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/CodeComplete/" rel="next" title="Code Complete, 2nd by Steve McConnell">
                <i class="fa fa-chevron-left"></i> Code Complete, 2nd by Steve McConnell
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Sample-ASP-NET-Core-Web-API-project/" rel="prev" title="Sample ASP.NET Core Web API project">
                Sample ASP.NET Core Web API project <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Содержание
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Обзор
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Артём Карпов</p>
              <p class="site-description motion-element" itemprop="description">Разработка ПО</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">Архив</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">Тэги</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:artyomkarpov@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/artkpv" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://linkedin.com/in/artkpv" target="_blank" title="Linkedin">
                      
                        <i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://stackoverflow.com/users/511144" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.hackerrank.com/ArtyomKarpov" target="_blank" title="Hackerrank">
                      
                        <i class="fa fa-fw fa-line-chart"></i>Hackerrank</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://codeforces.com/profile/artworks" target="_blank" title="Codeforces">
                      
                        <i class="fa fa-fw fa-bar-chart"></i>Codeforces</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Задача"><span class="nav-number">1.</span> <span class="nav-text">Задача</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Проблемы-с-синхронизацией"><span class="nav-number">2.</span> <span class="nav-text">Проблемы с синхронизацией</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Блокированные-философы"><span class="nav-number">2.1.</span> <span class="nav-text">Блокированные философы</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Голод-философов"><span class="nav-number">2.2.</span> <span class="nav-text">Голод философов</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Смерть-философа"><span class="nav-number">2.3.</span> <span class="nav-text">Смерть философа</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Официант"><span class="nav-number">3.</span> <span class="nav-text">Официант</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Решения-в-пространстве-пользователя"><span class="nav-number">3.1.</span> <span class="nav-text">Решения в пространстве пользователя</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Решения-в-режиме-ядра"><span class="nav-number">3.2.</span> <span class="nav-text">Решения в режиме ядра</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Гибридные-решения"><span class="nav-number">3.3.</span> <span class="nav-text">Гибридные решения</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Заключение"><span class="nav-number">4.</span> <span class="nav-text">Заключение</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Источники"><span class="nav-number">5.</span> <span class="nav-text">Источники</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Артём Карпов</span>

  

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.1</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  





  

  

  

  
  

  

  

  

</body>
</html>
